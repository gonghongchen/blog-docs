# 新系统主题切换功能的总结

## 功能描述
新系统的主题色切换功能包含全局的主题色适配和一键切换及本地（localStorage）状态存留，目前包含的主题色有蓝色（缺省值）、绿色和橙色。

## 技术实现点
1. 主题色切换功能、本地存储已切换的主题色状态，下次进来直接使用；
2. 打开副屏后，主屏切换了主题色后副屏需要同步修改；
3. 主题色需要适配新项目内部的 Element 组件、使用了主题色的文本、icon等。

## 使用方式（必看）
1. **问：怎么新增一个主题色？**

    答：在 `theme.ts` 文件内的 `skinList` 变量内按照既定格式新增一条主题色配置即可，其它就没什么要做的了。
2. **问：怎么使用主题色？**

    答：使用主题色的全局 css 变量即可，这样：`var(--el-color-primary)`，还有 `--el-color-primary-light-*`（* 表示 1-9 的数字）系列可以使用；
3. **问：怎么使用 icon？**
    
    答：如果使用的 icon 是需要适配主题色的，那需要下载 svg 文件格式，然后把 `.svg` 后缀改为 `.svgcom` 格式（如果有疑问为什么要用这个文件后缀，详见具体实现的描述），用于标识这个 svg 文件需要被处理为一个 Vue 组件，然后这样引用：
     ```js
    import CustomTaskIcon from '@/assets/icons/custom-task.svgcom'
    ```
    这样使用：
    ```html
    <CustomTaskIcon class="theme-svg" />
    <!-- 或者 -->
    <component :is="CustomTaskIcon" class="theme-svg" />
    ```
    注：`theme-svg` 是预定义的一个全局 less 变量，用于统一设置 svg 的色值为主题色，所以在使用 icon 时，加上这个类就好了，不需要再额外去写样式了，当然，如果你的 svg 文件有特殊样式需求就自己写吧。

## 具体实现（如果你想了解整个思路历程可以看看）
1. 对于技术实现点的第1、2个，是在原有的 `theme.ts` 的基础上进行了修改和完善，主题色相关的基础功能实现都是包含在内的，以后如果有新增相关功能代码也应该放这里面，其中核心方法 `setTheme` 内实现了主题色切换、本地存储及副屏通知的功能。全部代码详见 `theme.ts`，下面是 `setTheme` 实现：
    ```js
    export function setTheme(type?: string) {
      if (!type) {
        type = (ITS.storage.get(THEME_COLOR_TYPE) || skinList[0].type) as string
      } else {
        ITS.storage.set(THEME_COLOR_TYPE, type)
      }

      const themeVar = getThemeVar(type)
      const root = document.querySelector('html')

      Object.entries(themeVar).forEach(item => {
        const [key, val] = item
        root!.style.setProperty(key, val)
      })

      // 副屏已打开的情况下，通知副屏切换主题色
      if (localStorage.getItem('HAS_SUBSCREEN')) {
        ITS.event.emit('NOTICE_SUBSCREEN', {
          type: 'SWITCH_THEME_COLOR',
          data: {
            type
          }
        }, true)
      }
    }
    ```
  
2. 对于 Element 组件的主题色适配，是基于 less 做的样式覆盖实现的，核心点在于 Element 组件内的样式定义本质上是基于一套固定的基础变量来做的，其中基础主题色所涉及的变量就是 `--el-color-primary`，并基于此衍生出了不同透明度的 `--el-color-primary-light-*` 系列的色值，所以适配 Element 组件的主题色主要是对这两个色值进行 root 层级的覆盖：
    ```less
    :root {
      --el-color-primary: rgba(var(--base-red-val), var(--base-green-val), var(--base-blue-val), 1);
      --el-color-primary-dark-2: rgba(var(--base-red-val), var(--base-green-val), var(--base-blue-val), 0.9);
      .loop(9);
    }

    .loop(@count) when (@count > 0) {
      .loop(@count - 1);

      --el-color-primary-light-@{count}: rgba(var(--base-red-val), var(--base-green-val), var(--base-blue-val), (10 - @count) / 10);
    }
    ```
    然后需要考虑的则是怎么把切换主题色的功能和上面这个样式覆盖的代码结合起来，可能会考虑写三套主题色覆盖的独立样式文件出来，在切换主题色的时候加载对应的样式即可，但这样显然不够优雅，应该考虑以最小代价来实现主题色功能的拓展性，所以这里的实现方案是基于这一套覆盖主题色的代码来考虑如何实现切换方案，如上面代码所示，新定义了三个新的变量：`--base-red-val`、`--base-green-val`、`--base-blue-val`，这三个值就是 rgb 中的三原色的数值对应的基础 css 变量，那么在切换主题色的时候实际上只需要更改这三个值即可。切换功能代码详见 `theme.ts`，定义如下：
    ```js
    export const skinList = [
      {
        label: '蓝色',
        type: 'blue',
        theme: {
          red: 22,
          green: 119,
          blue: 255,
        },
      },
      {
        label: '绿色',
        type: 'green',
        theme: {
          red: 68,
          green: 135,
          blue: 109,
        },
      },
      {
        label: '橙色',
        type: 'orange',
        theme: {
          red: 255,
          green: 92,
          blue: 4,
        },
      },
    ]
    ```
    以后如果需要新增其它主题色，只需要在这个配置里面新增一项即可（切换主题色的配置功能也是根据这个来实现的）。

3. 对于需要使用主题色的其它自定义组件、文本等内容，都应该使用 `var(--el-color-primary)` 的方式进行定义，而不能直接使用具体的色值，如果后面设计稿出现了新的类似于主题色但又和主题色不一致的非特定固定色值的情况，应该和设计师进行沟通，需要保持主题色的一致性。例如：
    ```less
    // 好的
    .text {
      color: var(--el-color-primary);
      &:hover {
        color: var(--el-color-primary-light-3);
      }
    }
    // 不好的
    .text {
      color: rgba(22, 119, 255, 1);
      &:hover {
        color: rgba(22, 119, 255, 0.7);
      }
    }
    ```

4. 对于 icon 的主题色适配，这是一个比较复杂的问题，我们项目里面使用的 icon 是 svg 文件，设计师给的 svg 切图文件往往是自带颜色填充的，例如某个 svg 文件里面就有这样一段结构：
    ```html
    <rect id="矩形" fill="#000000" opacity="0" x="0" y="0" width="16" height="16"></rect>
    ```
    所以首先需要解决怎么进行主题色覆盖的问题，了解 svg 同事应该知道在通过 use href 的方式使用 svg 时，可以通过先把 svg 文件内的所有 fill 色值全部改成 `currentColor` 即可实现在业务层对 svg 内部颜色的自定义，至于怎么改成  `currentColor` 可以有两种方式，第一种也是最原始的方式——手动一个一个文件改就好了，智能的方式就是用第三方插件在构建时自动处理，或者自己写个 node 的工具方法跑一下也行。

    但是，这种方式有两个问题：1. 对于单色的 icon 可以这样处理，但对于双（多）色的 icon 则不行，因为双色 icon 的 svg 内部会针对 rect、path 做不同的颜色处理，若把它们的 fill 全部改成  `currentColor`，会导致变成单色的了，所以对于双色的 icon，需要在外层分别对 rect、path 进行区分修改 fill 的色值；2. 就是如前文描述的那样，还需要考虑内部的 fill 的填充的色值的问题，需要手动或自动处理一下，这也是比较麻烦的过程。

    综上两个问题来看，需要一种新的方式来更好的处理，我们知道对于已知的渲染到了页面上的各种 HTML 标签组成的 DOM 结构，我们是可以进行样式设置的，那么同理，如果能直接把 icon 的 svg 文件内部的 DOM 结构渲染出来也就可以实现样式层面的直接处理了，为了达到这样的需求，就需要考虑如果进行渲染，在 Vue 项目里面就是考虑如何把 svg 文件以组件的形式渲染出来，首先我想到的就是用个第三方插件来完成，即 `vite-svg-loader`，这个插件确实很棒，提供了可以在 import svg 文件的时候通过增加 query 为 component 的标识来将 svg 的导入转变为一个 Vue 组件，这样就达到了预期的效果，可正当我开开心心的在本地开发的时候，却忽然意识到了一个很严重的问题，那就是我记得之前在看 `icorejs` 文档的时候有说过使用这个框架搭建的项目开发环境是用的 vite 构建，而生产环境却是使用的 webpack 进行构建，然后我马上去看了下 `vite-svg-loader` 是否支持 webpack，结果是不支持的，那现在就要考虑去再找一个具有同等可替代的 webpack 版本的插件了，结果找了一圈，能和 `vite-svg-loader` 一致的使用方式的确实没有，针对 webpack 的 loader 倒是有一个 `vue-svg-loader`，但是这个对 svg 文件的处理是全局的，对，这里还要说明一个很重要的问题就是，由于我们项目里面用到了很多 svg 的 icon，有些是不需要处理成导入组件的，因为不需要适配主题色所以直接通过 img 的方式引用了，也就是说在项目内，只需要针对适配主题色的 svg 文件才应该被处理成导入组件的形式，那 `vue-svg-loader` 就完全不满足了，况且这个库的内部实现也就是对 svg 文件增加了一个 template 包裹，太简单粗暴了，而且我试了下在我们项目里面还跑步起来……。

    问题发展到了现在这个时候，真的就需要考虑如何自力更生了，也即自己去实现一个 webpack loader 去按照 `vite-svg-loader` 的处理方式一样来解决生产环境遇到的问题，要实现这个 loader 的核心就是要明白 svg 转 Vue 组件的核心功能是什么，我们知道 Vue 单文件组件里面包含了 template 模块，这个模块就是针对 DOM 的描述，而这个模块在编译之后实际上会被转换为一个 render 方法，这个方法内部其实就是各种对创建虚拟 DOM 的方法的调用，而 icon 的 svg 文件的代码其实就可以当做是这么一个 template 模块，loader 需要做的事情就是把它进行编译，然后转换成 render 输出即可，至于怎么转换成 render 呢，当然是用 Vue 的一个内部方法 `compileTemplate` 来实现啦，不然如果自己去实现这个逻辑，那真的是太难了，所以，最终实现的 loader 如下：
    ```js
    const { compileTemplate } = require('@vue/compiler-sfc')
    const { optimize } = require('svgo')

    function svgLoader(svg) {
      // 压缩 SVG 图像，消除冗余信息，减少文件大小
      const newSvg = optimize(svg, {
        path: this.resourcePath
      }).data

      // 编译
      const { code } = compileTemplate({
        id: this.resourcePath,
        source: newSvg,
        filename: this.resourcePath,
        transformAssetUrls: false
      })
      return `${code}\nexport default { render: render }`
    }

    module.exports = svgLoader
    ```
    webpack 配置如下：
    ```js
    chainWebpack(config) {
      config.module
        .rule('svg-loader')
        .test(/\.svgcom$/)
        .use('./svg-loader/index.cjs')
        .loader('./svg-loader/index.cjs')
        .end()
    },
    ```
    到这里，webpack 的 loader 问题算是解决了，然后就需要考虑怎么针对只需要适配主题色的 icon 进行这样的流程处理而不需要适配主题色的 icon 的导入方式则不变的问题了，上面说过 `vite-svg-loader` 可以通过在 import 的时候可以通过增加 query 为 component 的标识来将 svg 的导入转变为一个 Vue 组件，那其实 webpack loader 也可以按这种效果来实现，`icorejs` 提供了 `chainWebpack` 这个 api 来让项目可以配置相应的 webpack 的 loader 内容，所以我可以在这里面配置 svg 的规则，通过使用 `rule.oneof` 配合 `rule.resourceQuery: /component/` 来针对 `*.svg?component` 的这种文件导入格式走上面写的这个 loader 的处理，从而保持开发环境和生产环境的统一处理，但这个时候遇到了一个巨大的坑，那就是无论我对生产环境的 webpack 如何配置，最终 build 后，svg 文件都会被转换为 base64 的 image 格式，一度怀疑是自己配置哪儿有问题，直到我通过莉辉找到了这个 https://umijs.org/docs/guides/plugins 文档后，通过里面提供的 `modifywebpackconfig` 方法拿到了打包时全部的 webpack 配置，找到了与 svg 处理相关的配置信息，里面确实有一条通过 svgo 针对 svg 的处理规则，这个规则应该是不具备转成 base64 的功能的，而且即使我把这条规则删了或者修改了，打包后还是会输出 base64 的格式，所以到这里，我只能理解为 `icorejs` 框架内可能还有针对 svg 的强处理，比如用 `url-loader` 处理成图片了，我这边在项目使用的层面可能真的改不了了，只能等以后再看了，或者如果看到这儿的你是知道什么原因，烦请告知，如果能直接提供解决方案就更好了。话又说回来，问题还是要解决的，既然 svg 文件本身我已经没法处理了，那我换个文件格式就行了，于是 `.svgcom` 文件就诞生了，通过这个后缀来标识这是一个 import 时会被转换为 component 的 svg 文件，引入方式如下：
    ```js
    import CustomTaskIcon from '@/assets/icons/custom-task.svgcom'
    ```
    使用方式如下：
    ```html
    <CustomTaskIcon class="theme-svg" />
    <!-- 或者 -->
    <component :is="CustomTaskIcon" class="theme-svg" />
    ```
    `theme-svg` 是预定义的一个全局 less 变量，用于统一设置 svg 的色值为主题色，所以在使用 icon 时，加上这个类就好了，不需要再额外去写样式了，当然，如果你的 svg 文件有特殊样式需求就自己写吧。
    ```less
    // :global {
    .theme-svg {
      rect {
        fill: var(--el-color-primary-light-9);
      }

      path {
        fill: var(--el-color-primary);
      }
    }
    // }
    ```
    所以，后续在新增需要适配主题色的 icon 的 svg 文件时，需要把后缀改成 `.svgcom` 哦，这个处理方式我自己也觉得不够优雅，如果以后能搞定上述 svg 的问题就再改一下，成本也不大。可能你已经注意到了，虽然生产环境的问题解决了，但是这个引入方式和前面说的开发环境的引入方式又不一样了，那怎么办，其实很好办，那就是开发环境的 `vite-svg-loader` 也不要了，也自己写一个针对 vite 的插件出来就行了，反正也用不到它提供的所有功能，而且这样还可以避免多安装一个第三方插件，哈哈哈（我这么安慰自己道），具体实现的核心功能其实是和 webpack 的loader 一样的，只是多了读取文件的处理罢了。实现如下：
    ```js
    // 适用于 vite 构建流程
    import { compileTemplate } from '@vue/compiler-sfc'
    import { optimize } from 'svgo'

    const fs = require('fs').promises

    function svgLoader () {

      return {
        name: 'svg-loader',
        enforce: 'pre',

        async load (path) {
          if (!(/\.svgcom$/).test(path)) {
            return
          }

          let svg = ''

          try {
            svg = await fs.readFile(path, 'utf-8')
          } catch (ex) {
            console.warn('\n', `${path} couldn't be loaded by svg-loader.`)
            return
          }

          // 压缩 SVG 图像，消除冗余信息，减少文件大小
          svg = optimize(svg, {
            path
          }).data

          // 编译
          const { code } = compileTemplate({
            id: path,
            source: svg,
            filename: path,
            transformAssetUrls: false
          })

          return `${code}\nexport default { render: render }`
        }
      }
    }

    export default svgLoader
    ```