# Git 实用命令指南

### **问：已经在本地的分支 A 修改了代码，又要紧急切换到分支 B 修改代码该怎么处理？**

答：

方法一：
1. 将本地对分支 A 做的修改使用命令 `git stash save 'message'` 存储起来；
2. 待分支 B 修改完成后再切换到分支 A 时，再通过命令 `git stash pop` 进行恢复即可；
3. 如果有多次 stash 操作，还可以通过命令 `git stash list` 查看所有存储信息。

方法二：

1. 先将分支 A 修改的内容跑 `git commit` 命令进行提交，但不要 push 到远程分支了；
2. 待分支 B 修改完成后再切换到分支 A 时，再通过命令 `git log` 查看上次提交的内容的前一条记录的 hash 值是多少；
3. 再跑命令 `git reset --soft [hash 值]` 将之前提交的内容回退到暂存区即可。


### **问：如何修改已经提交了的 commit message？**

答：
1. 先用 `git log` 找到需要修改的 commit 记录的前一条记录的 hash 值；
2. 然后执行 `git rebase -i [hash 值]` 命令，这会进入交互式界面，输入 `i` 进入编辑模式，在其中找到要修改的 commit 所对应的行，将行首的 `pick` 改为 `reword` 或 `r`；
3. 编辑完成后再按下 `esc` 退出编辑模式，输入 `:wq` 保存并退出；
4. 然后会依次进入到每个要修改的 commit 的编辑界面，输入 `i` 进入编辑模式，然后修改 commit message 即可;
5. 修改完成后按下 `esc` 退出编辑模式再输入 `:wq` 保存并退出，如果没有冲突那到这里就结束了；
6. 如果有冲突需要解决则继续解决冲突，解决完一个后执行命令 `git rebase --continue` 进入到下一个，直到所有冲突解决完成并结束；
7. 最后使用 `git log` 命令查看修改后的 commit message 是否正确。


### **问：如何回退代码到本分支的指定提交记录或者指定分支的最新记录？**

答：
1. 先用 `git log` 找到需要回退到的该记录的 hash 值；
2. 再跑命令 `git reset --hard [hash 值]` 即可将当前分支回退到该 commit 节点，需要注意的是这个命令会将指定 hash 值之后的提交记录全部删除，所以需要谨慎使用，最好是只在本地使用；
3. 如果是要回退到其它分支的最新 commit 节点，需要先跑命令 `git pull [remote] [branch]` 获取该分支的最新记录，然后再跑命令 `git reset --hard [remote/branch]` 即可，例如回退到 origin 仓库的 master 分支上就应该是：先 `git pull origin master`，再 `git reset --hard origin/master`。PS：如果想要回退到其它分支的指定 commit 节点，那就在这个步骤之后再跑一下 1 和 2 步骤即可。


### **问：如何撤回指定的提交记录？**

答：
1. 先用 `git log` 找到需要撤回的记录的 hash 值；
2. 再运行命令 `git revert [hash 值]`，此时会进入到编辑 message 的命令行界面，输入 `i` 进入编辑模式可以对提交信息进行编辑，编辑完成后再按下 `esc` 退出编辑模式，最后在命令行输入 `:wq` 保存退出即可。


### **问：如何将本地分支 A 的某项提交记录复制到 本地分支 B 上面？**

答：
1. 先用 `git log` 找到分支 A 中需要复制的记录的 hash 值；
2. 再在分支 B 中跑 `git cherry-pick [hash 值]` 即可。


### **问：git merge 和 git rebase 有什么区别以及怎么选用？**

答：
* 在合并代码的时候，我们可能会直接跑 `git pull` 命令，这个命令实际上是 `git fetch` 和 `git merge` 的组合，会自动进行分支拉取和记录合并，当然也可以分开跑，这个方式的特点在于每次合并代码的那一次操作也会生成一次新的 commit 记录，即我们常见的这样的提交信息：`Merge branch '***' into '***'`，优点是会保持 commit 的时间线不变。
* `git rebase` 俗称变基，是另一种合并代码的策略，相对于 `git merge` 来说，它不会生成新的 commit 记录，显得更加优雅，但它会改变 commit 的时间线，例如：当前分支 A 的记录为 a -> b -> c -> d -> f，远程分支 B 的记录为 a -> b -> c -> e -> g，若执行了 `git rebase origin/B`，那记录就会变成：a -> b -> c -> e -> g -> d -> f，也即将 B 分支的新记录作为新的起点，将 A 分支的最新提交记录放在最后面。
* 这两种方式各有优劣，只要项目有一个统一的使用方式即可，用谁倒也没有绝对的说法，当然我更推荐用 merge，因为时间线还是有必要保留的，多的那一次合并记录也是有必要保留的，都是方便后续排查问题。